\newpage 
\section{Programando una aplicación robótica con esquemas}
\label{sec:esquemas}

%hebras de servicio
Como hemos descrito en la sección \ref{sec:sensact}, \textit{jdec} uniformiza el acceso a sensores y actuadores a través de variables compartidas, tanto si provienen del robot real, del robot simulado o de acceso remoto. Sobre este interfaz software
%suelo software, interfaz de software, suelo estándard
se escribe el programa de la aplicación robótica. Para mantener este interfaz activo la plataforma ejecuta un conjunto de \textit{hebras de servicio}. Hay hebras de servicio que se encargan de recoger los datos de los sensores locales, de enviar los comandos a los actuadores locales, otras dialogan con el simulador y otras materializan la comunicación con los servidores de red. Cada ejecución de la plataforma se corresponde a una aplicación robótica, y para cada una de ellas se especifica en un fichero de configuración (\texttt{jde.conf}) qué variables perceptivas y de actuación se van a usar y de dónde provienen (hardware local, simulador, servidores de red), para que la plataforma ejecute las hebras de servicio oportunas.

%Modelo concurrente
%aplicación como una, varias o muchas hebras
Sobre este interfaz, \textit{jdec} plantea la aplicación robótica como una o más hebras específicas que se ejecutan concurrentemente. La aplicación robótica puede constar de una única hebra en los casos sencillos, de varias en caso de comportamientos más elaborados o de un amplio conjunto dinámico de ellas en los comportamientos más complejos. Por lo tanto, \textit{jdec} es un sistema \textit{multihilo} que tiene hebras de servicio y hebras específicas de la aplicación robótica ejecutándose en paralelo. En la implementación actual esas hebras se han materializado con la biblioteca \texttt{pthreads}.

\subsection{¿Qué es un esquema?}

%esquema, flujo ejecución iterativo e interrumpible
Más que dejar libre el diseño de esas hebras de la aplicación, \textit{jdec} ofrece la abstracción \textit{esquema} para estructurar su funcionamiento y que así las aplicaciones se puedan combinar de manera sencilla. Un \textit{esquema} es un flujo de ejecución que tiene un objetivo propio y funciona en iteraciones periódicas a un ritmo controlado. Para \textit{jdec} el \textit{esquema} es la unidad básica de comportamiento y la aplicación robótica consta de un conjunto dinámico de \textit{esquemas} funcionando concurrentemente. Encorsetar las hebras de la aplicación en los respectivos esquemas permite encapsular mejor la funcionalidad en unidades reutilizables para otras aplicaciones y simplificar la comunicación entre esas unidades.


\begin{table}
% \lstinputlisting[language=C,caption={Interfaz de un esquema}]{src/interfaz.c}
\begin{lstlisting}[language=C]
/*Indentificador del esquema*/
extern int myschema_id;
/* variables de modulacion */
int myschema_cycle; /* tiempo de ciclo en ms */ 
/* variables de entrada */
/* variables de salida */

extern void myschema_startup();
extern void myschema_suspend();
extern void myschema_resume(int father, int *brothers, arbitration fn);
extern void myschema_guiresume();
extern void myschema_guisuspend();
\end{lstlisting}
\caption {Interfaz de un esquema}
\label{tabla:interfazesquema}
\end{table}

Los \textit{esquemas} se comunican entre sí a través de funciones o variables compartidas y se pueden detener y relanzar a voluntad. Para que un esquema establezca como compartidas algunas de sus funciones o variables, esto es, exportarlas a otros esquemas, ha de indicarlo explícitamente a través de la función \texttt{myexport}. De igual manera, para que un esquema haga uso de variables o funciones compartidas, es decir, importarlas desde otros esquemas, debe llamar a la función \texttt{myimport}.

%interfaz de esquema: startup, suspend y resume
Cada esquema tiene un nombre y cinco funciones asociadas, que tienen el nombre del esquema como prefijo. En la tabla \ref{tabla:interfazesquema} se muestran las de \texttt{myschema} a modo de ejemplo. La función \texttt{startup} se usa para dar de alta al esquema en el sistema e inicializarlo. La función \texttt{resume} para arrancar la ejecución iterativa o reactivarla. La función \texttt{suspend} detiene la ejecución iterativa. Mediante estas funciones el sistema puede inicializar nuevos esquemas, unos esquemas pueden detener y relanzar a otros, etc..

%comunicación a través de variables
Cada esquema comunica sus resultados continuamente a través de unas variables (variables de salida) que él refresca, recoge continuamente los resultados de otros esquemas (de los cuales puede depender) a través de otras variables (variables de entrada) y admite cierta modulación en su propio funcionamiento a través de otras variables (variables de modulación) que otros esquemas pueden escribir. Las variables de entrada de un esquema pueden ser variables perceptivas de la plataforma o variables de salida de otros esquemas. Las variables de salida de un esquema pueden ser variables de actuación de la plataforma, variables de entrada para otros esquemas o variables de modulación para otros esquemas.

%condiciones de carrera
En el acceso a esas variables, así como a las variables perceptivas y de actuación que ofrece la plataforma, pueden presentarse condiciones de carrera, pues hay varios hilos de ejecución accediendo concurrentemente a ellas. Por ejemplo, la plataforma actualiza (escribe) una variable perceptiva y cuando va por la mitad otro esquema la lee. Una condición de carrera de este estilo se puede apreciar en la captura y visualización de las imágenes que son mezcla de la actual y la anterior. Estas condiciones de carrera pueden desembocar en que en una iteración un esquema no tenga buenos datos de entrada o no envíe buenas órdenes a los actuadores, pero no son muy dañinas porque enseguida llega la iteración siguiente que muy probablemente funcione de manera correcta. Dado su carácter esporádico y el planteamiento continuo de \textit{jdec} no son muy preocupantes. Salvo casos delicados, hemos decidido no evitarlas con semáforos para no ralentizar la ejecución del sistema. 

Cada esquema tiene una hebra asociada que ejecuta un esqueleto de código. En ese esqueleto hay un bucle infinito y en cada pasada del bucle se ejecuta una iteración del esquema, contenido en la función \texttt{myschema\_iteration}. Mediante esperas controladas, se domina el ritmo al que se ejecutan las iteraciones del esquema. Más allá de este esqueleto, \textbf{que proporciona la plataforma \textit{jdec}}, el programador de aplicaciones debe escribir en \texttt{myschema\_iteration} el código genuino del esquema, el que resuelve su tarea concreta. Se hace hincapié en que el código que se escribe en la función \texttt{myschema\_iteration} \textbf{se ejecuta de forma iterativa}, no es necesario que el programador añada esta característica en el código del esquema.

La variable \texttt{myschema\_cycle} es un ejemplo de variable de modulación, que afecta al funcionamiento del esquema (en este caso el ritmo de su ejecución) y que puede ser modificada por otros esquemas durante la ejecución. De esa manera el esquema que modifica esa variable de modulación puede conseguir que \texttt{myschema} ejecute rápidamente durante cierto tiempo y más pausadamente, a menor frecuencia, en otro.

\subsection{Aplicación con un esquema}
%partimos de una hebra sin el corsé de los esquemas.
En el caso más sencillo la aplicación robótica consta de una única hebra, por ejemplo una que materializa un bucle infinito en el cual (1) se leen datos de algunas variables sensoriales, (2) se deciden reactivamente los comandos adecuados para reaccionar ante esa situación y (3) éstos se escriben en las variables de actuación pertinentes.

El modo natural de encajar esto en un esquema es programar que en cada iteración del esquema se realicen esos tres pasos, hacer coincidir cada iteración del esquema con una iteración del bucle reactivo. Una ventaja es que el ritmo de ejecución del esquema está controlado por la plataforma, de manera que se puede conseguir que ejecute a 10 iteraciones por segundo si con eso resulta suficiente para la aplicación, o a 20 si es necesario. De esta manera no se dedica más tiempo de CPU al esquema que el necesario para la naturaleza aplicación, haciéndola más eficiente. Otra ventaja es que al encapsular en un esquema, éste se puede detener sin necesidad de abortar toda la aplicación.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=9cm]{figs/appunesquema}
\end{center}
\caption{Aplicación con un único esquema}
\label{fig:aplicacion-un-esquema}
\end{figure}


%ejemplo de esquema navegación controlada por posición 
Por ejemplo, queremos que el robot se mueva en dos círculos yuxtapuestos, describiendo la figura de un ocho. Esto se puede conseguir con un único esquema que materializa un control basado en posición: lee los datos de posición y ordena las velocidades de giro y avance oportunas. En particular con un autómata de estados.

%ejemplo de esquema navegación reactiva alejandose de obstáculos, vff

%no hay magia: sensores y actuadores
El programa que controla el comportamiento del robot sólo percibe la realidad a través de las medidas sensoriales crudas. Las decisiones han de ser expresadas como comandos a los actuadores. Precisamente la aplicación enlaza unas cosas con otras, no hay magia. 

\subsection{Aplicación con varios esquemas al mismo nivel}

El planteamiento anterior, con un \textit{único} esquema, es suficiente para aplicaciones robóticas relativamente simples, como los comportamientos reactivos, donde el robot sólo tiene que hacer una tarea y la información adecuada ya se encuentra directamente accesible en los datos sensoriales crudos. Sin embargo, cuando el robot tiene que estar pendiente de varios estímulos, o los estímulos subyacen en los datos sensoriales pero no directamente sino que necesitan cierto procesamiento, o cuando la actuación se puede agrupar en distintos modos o fases diferenciadas, etc. entonces puede resultar conveniente utilizar \textit{varios} esquemas para programar la aplicación robótica que genera el comportamiento del robot.

%esquemas perceptivos y esquemas de actuación
Cuando se van a utilizar varios esquemas en la aplicación, \textit{jdec} distingue entre \textit{esquemas perceptivos} y \textit{esquemas de actuación}. Los esquemas perceptivos tienen como tarea buscar o construir un cierto estímulo perceptivo desde las lecturas sensoriales o desde la información elaborada por otros esquemas perceptivos. Los esquemas de actuación toman decisiones de control y tienen como tarea conseguir cierto comportamiento.

%percepción como colección de estímulos
La percepción en \textit{jdec} se entiende como un conjunto dinámico de estímulos. Cada estímulo es elaborado por un esquema perceptivo y se almacena en sus variables de salida, que los esquemas de actuación que lo necesitan toman como variables de entrada. El esquema perceptivo se encarga, cuando es activado, de mantener esas variables actualizadas y en correspondencia con la realidad, que es dinámica.

%actuación
Los esquemas de actuación toman sus decisiones de control a partir de los estímulos, son toda la información que tienen para ello. Sus decisiones se expresan como valores concretos para las variables de actuación, que ellos toman como sus variables de salida.

En el fichero de configuración, también se determinan los esquemas que se van a arrancar. Su activación posterior depende de las condiciones de activación y la situación del entorno del robot. En el fichero de configuración también se pueden activar trazas de depuración, por cada esquema.


\begin{figure}[htb]
\begin{center}
\includegraphics[width=9cm]{figs/appunnivel}
\end{center}
\caption{Aplicación con varios esquemas en el mismo nivel}
\label{fig:aplicacion-un-nivel}
\end{figure}


Especialistas de actuación = varios esquemas de actuación, cada uno con sus precondiciones.

Estímulos más elaborados que las simples lecturas sensoriales = esquemas perceptivos, unos toman las salidas de otros, construyendo estímulos más complejos. Típico en visión.

%ejemplo: robot sigue persona con vision (sin cuello mecánico)

\subsection{Aplicación con jerarquía de esquemas}

Las aplicaciones con un esquema o con un conjunto de ellos en el mismo nivel se pueden catalogar como programación sencilla con \textit{jdec}. La programación de  aplicaciones robóticas con una jerarquía dinámica de esquemas se podría encajar en programación avanzada con \textit{jdec}, en la cual se usan mecanismos de arbitraje, monitorización contínua, precondiciones, etc. relativamente complejos y potentes.

\begin{figure}
\begin{center}
\includegraphics[width=9cm]{figs/esquemasjde}
\end{center}
\caption{Aplicación robótica implementada con una jerarquía dinámica de esquemas}
\label{fig:app-jerarquia}
\end{figure}
%jerarquía
Unos esquemas utilizan las variables que otros actualizan. También los esquemas pueden activar y modular a otros para que materialicen el comportamiento que le interesa. La plataforma materializa la arquitectura cognitiva Jerarquía Dinámica de Esquemas \cite{canas03} para la generación de comportamientos en robots móviles. 
Para poder combinar varias 
 puede constar de varias hebras y para comportamientos complejos es necesario organizar la ejecución de esas hebras de modo jerárquico.
